use std::{collections::HashMap, marker::PhantomData};

use config::{builder::DefaultState, ConfigBuilder, File, FileFormat};
use serde::{Deserialize, Deserializer};

use crate::error::ScrapeError;

#[derive(Debug)]
struct Selector {
    selector: String,
    value: SelectorValue,
}

#[derive(Debug, Deserialize)]
struct SelectorDe {
    selector: String,
    value: SelectorValue,
}

impl<'de> Deserialize<'de> for Selector {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Selector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("string or array of strings")
            }

            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                Ok(Selector {
                    selector: value.to_string(),
                    value: SelectorValue::AllText,
                })
            }

            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                let s = SelectorDe::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(Selector {
                    selector: s.selector,
                    value: s.value,
                })
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

#[derive(Debug)]
enum SelectorValue {
    OwnText,
    AllText,
    Attributes(Vec<String>),
}

impl<'de> Deserialize<'de> for SelectorValue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SelectorValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("string or array of strings")
            }

            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "own-text" => Ok(SelectorValue::OwnText),
                    "all-text" => Ok(SelectorValue::AllText),
                    _ => Err(serde::de::Error::custom(
                        "expected own-text or all-text".to_string(),
                    )),
                }
            }

            fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let values: Result<Vec<String>, A::Error> = serde::de::Deserialize::deserialize(
                    serde::de::value::SeqAccessDeserializer::new(seq),
                );
                Ok(SelectorValue::Attributes(values?))
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

#[derive(Debug, Deserialize)]
struct Chapter {
    base: Selector,
    title: Selector,
    number: Option<Selector>,
    date: Option<Selector>,
    url: Selector,
    fetch_external: Option<Vec<ExternalFetch>>,
}

#[derive(Debug, Deserialize)]
struct ExternalFetch {
    id: Selector,
    regex: String,
    url: String,
}

#[derive(Debug, Deserialize)]
struct Manga {
    title: Selector,
    description: Selector,
    cover_url: Selector,
    status: Selector,
    authors: Selector,
    genres: Selector,
    alt_titles: Selector,
    chapter: Chapter,
}

#[derive(Debug, Deserialize)]
struct SearchQueryFormat {
    replace_regex: String,
    replace_with: String,
}

#[derive(Debug, Deserialize)]
struct SearchSelectors {
    base: Selector,
    url: Selector,
    title: Selector,
    cover_url: Option<Selector>,
    posted: Option<Selector>,
}

#[derive(Debug, Deserialize)]
struct SearchConfig {
    search_url: String,
    query_format: Option<SearchQueryFormat>,
    selectors: SearchSelectors,
}

#[derive(Debug, Deserialize)]
struct MangaScraperConfig {
    manga: Manga,
    search: SearchConfig,
    date_formats: Vec<String>,
}

#[test]
fn test_config() {
    let json_str = include_str!("../../configs/madara.yaml");

    let config = ConfigBuilder::<DefaultState>::default()
        .add_source(File::from_str(json_str, FileFormat::Yaml))
        .build()
        .unwrap()
        .try_deserialize::<MangaScraperConfig>()
        .unwrap();

    println!("{:#?}", config);
}
